#include <iostream>   // 입출력 관련 라이브러리
#include <vector>     // 동적 배열(vector) 사용을 위한 라이브러리
#include <string>     // 문자열(string) 사용을 위한 라이브러리
using namespace std;

// K번째 문자열을 찾기 위한 재귀 함수 선언
void find(int k);

// 전역 변수들
int MAX = 1000;          // 조합수를 계산할 때 사용할 최대 길이 (충분히 큰 값)
int number;              // 'a'와 'z'로 만들 수 있는 전체 문자열의 개수
int N, M, K;             // N: 'a'의 개수, M: 'z'의 개수, K: 찾고자 하는 K번째 문자열의 번호
// 조합수를 저장하는 2차원 벡터, d[i][j]는 i개 중 j개를 선택하는 조합의 수를 의미함.
// 단, 계산 값이 1,000,000,000을 초과하면 1000000001로 저장하여 오버플로우를 방지함.
vector<vector<int>> d(MAX+1, vector<int>(MAX+1, 0));
string str = "";         // 결과 문자열을 저장할 변수

int main() {
    // 빠른 입출력을 위한 설정
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // 조합수 계산 (파스칼의 삼각형 이용)
    d[0][0] = 1;   // 0개 중 0개 선택하는 경우는 1가지
    for (int i = 1; i < MAX; i++) {
        d[i][0] = 1;   // 어떤 i에 대해서도 0개를 선택하는 경우는 1가지
        for (int j = 1; j <= i; j++) {
            // 이전 단계의 조합수 합이 1,000,000,000보다 크면 오버플로우 방지를 위해 1000000001로 설정
            if (d[i-1][j-1] + d[i-1][j] > 1000000000) {
                d[i][j] = 1000000001;
            }
            else {
                d[i][j] = d[i-1][j-1] + d[i-1][j];   // 파스칼의 삼각형 점화식 이용
            }
        }
    }
    
    // 사용자로부터 'a'의 개수(N), 'z'의 개수(M), 그리고 K번째 문자열의 번호(K) 입력
    cin >> N >> M >> K;
    
    // 전체 문자열의 개수는 (N+M)개 중 N개(또는 M개)를 선택하는 조합과 같음
    number = d[N+M][N];
    
    // 만약 가능한 전체 문자열의 수가 K보다 작다면 K번째 문자열은 존재하지 않으므로 -1 출력 후 종료
    if (number < K) {
        cout << "-1";
        return 0;
    }
    
    // 재귀 함수를 이용하여 K번째 문자열을 구성
    find(K);
    
    // 결과 출력
    cout << str;
    return 0;
}

// 재귀 함수를 이용하여 K번째 문자열을 구성하는 함수
void find(int k) {
    // 남은 문자가 단 1개일 경우, 남은 문자에 따라 'a' 또는 'z'를 결과 문자열에 추가 후 종료
    if (N == 1 && M == 0) {  // 남은 문자가 'a' 1개만 남은 경우
        str.append("a");
        return;
    }
    
    if (M == 1 && N == 0) {  // 남은 문자가 'z' 1개만 남은 경우
        str.append("z");
        return;
    }
    
    // 현재 위치에서 'a'를 선택했을 때 만들 수 있는 문자열의 개수를 계산
    // 만약 첫 글자를 'a'로 고르면 남은 총 문자수는 (N+M-1)개이고,
    // 이 중 M개의 'z'를 선택하는 조합의 수가 a에 저장된다.
    int a = d[N+M-1][M];
    
    // K번째 문자열이 'a'로 시작하는 그룹에 속하는 경우
    if (k <= a) {
        str.append("a");   // 결과 문자열에 'a' 추가
        N -= 1;            // 'a' 개수를 하나 줄임
        find(k);           // 남은 문자열에서도 K번째 문자열을 재귀적으로 찾음
    }
    // K번째 문자열이 'z'로 시작하는 그룹에 속하는 경우
    else if (k > a) {
        str.append("z");   // 결과 문자열에 'z' 추가
        M -= 1;            // 'z' 개수를 하나 줄임
        find(k - a);       // 'a'로 시작하는 경우의 개수 a를 제외한 나머지에서 (k-a)번째 문자열을 찾음
    }
}
